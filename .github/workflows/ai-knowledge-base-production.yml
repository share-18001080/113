name: AI Knowledge Base (Production v1.0)

on:
  workflow_run:
    workflows: ["*"]
    types: [completed]

permissions:
  actions: read
  contents: write

jobs:
  ai-analyze-error:
    runs-on: ubuntu-latest
    if: |
      github.event.workflow_run.conclusion == 'failure' &&
      contains(github.event.workflow_run.name, 'ver') &&
      !contains(github.event.workflow_run.name, 'AI Knowledge Base')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Debug workflow info
        run: |
          echo "## üîç Workflow Info" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.event.workflow_run.name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Run ID:** ${{ github.event.workflow_run.id }}" >> $GITHUB_STEP_SUMMARY
          echo "**Run #:** ${{ github.event.workflow_run.run_number }}" >> $GITHUB_STEP_SUMMARY
          echo "**Conclusion:** ${{ github.event.workflow_run.conclusion }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.event.workflow_run.head_branch }}" >> $GITHUB_STEP_SUMMARY
          echo "**URL:** https://github.com/${{ github.repository }}/actions/runs/${{ github.event.workflow_run.id }}" >> $GITHUB_STEP_SUMMARY

      - name: Download and extract error context (Smart Exit Code Detection)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          FAILED_RUN_ID=${{ github.event.workflow_run.id }}
          
          echo "üì• Downloading log for run $FAILED_RUN_ID"
          
          curl -L \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/${FAILED_RUN_ID}/logs" \
            -o current-log.zip
          
          if [ ! -f current-log.zip ]; then
            echo "‚ùå Failed to download log"
            exit 1
          fi
          
          SIZE=$(stat -c%s current-log.zip 2>/dev/null || stat -f%z current-log.zip)
          echo "‚úÖ Downloaded: ${SIZE} bytes"
          
          unzip -q current-log.zip -d current-log/
          find current-log/ -name "*.txt" -exec cat {} \; > full-log.txt
          
          TOTAL_LINES=$(wc -l < full-log.txt)
          echo "üìä Total lines: $TOTAL_LINES"
          
          # CRITICAL: Find exit code markers (most accurate)
          echo "üîç Searching for exit code markers..."
          EXIT_CODE_LINES=$(grep -n "exit code [1-9]" full-log.txt | cut -d: -f1)
          
          if [ -z "$EXIT_CODE_LINES" ]; then
            echo "‚ö†Ô∏è No 'exit code' found, trying ##[error] marker"
            EXIT_CODE_LINES=$(grep -n "##\[error\]" full-log.txt | head -n 1 | cut -d: -f1)
          fi
          
          if [ -n "$EXIT_CODE_LINES" ]; then
            # Get first exit code (most important error)
            FIRST_EXIT=$(echo "$EXIT_CODE_LINES" | head -n 1)
            
            echo "‚úÖ Found exit code at line: $FIRST_EXIT"
            
            # Extract 3000 lines BEFORE exit code + 100 lines AFTER
            START_LINE=$((FIRST_EXIT - 3000))
            END_LINE=$((FIRST_EXIT + 100))
            
            if [ $START_LINE -lt 1 ]; then
              START_LINE=1
            fi
            
            if [ $END_LINE -gt $TOTAL_LINES ]; then
              END_LINE=$TOTAL_LINES
            fi
            
            echo "üìç Extracting lines $START_LINE to $END_LINE (context around exit code)"
            
            sed -n "${START_LINE},${END_LINE}p" full-log.txt > log-for-ai.txt
            
            EXTRACTED=$(wc -l < log-for-ai.txt)
            echo "üì§ Extracted $EXTRACTED lines for AI (focused on error)"
            
            # Show all exit codes found
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üö® Exit Codes Found:" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            grep "exit code" full-log.txt | head -n 10 >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            
          else
            echo "‚ö†Ô∏è No exit code or error marker found, using fallback"
            tail -n 5000 full-log.txt > log-for-ai.txt
            
            EXTRACTED=$(wc -l < log-for-ai.txt)
            echo "üì§ Extracted $EXTRACTED lines (fallback mode)"
          fi
          
          # Enhanced error preview with MORE context
          echo "üîç Verifying extracted log quality..."
          
          if grep -q "meson.build.*ERROR\|configure: error\|undefined reference\|ERROR:" log-for-ai.txt; then
            echo "‚úÖ Log contains build errors"
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üìã Error Preview (Enhanced Context):" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            
            # Show 50 lines BEFORE + 10 AFTER first error for full context
            grep -B50 -A10 "ERROR:\|error:" log-for-ai.txt | head -n 120 >> $GITHUB_STEP_SUMMARY
            
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è Log may not contain FFmpeg build errors"
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ‚ö†Ô∏è Warning: No Clear Error Pattern Found" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            tail -n 50 log-for-ai.txt >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Test Gemini API Key
        id: test_api
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          if [ -z "$GEMINI_API_KEY" ]; then
            echo "‚ùå GEMINI_API_KEY not set"
            exit 1
          fi
          
          TEST=$(curl -s -X POST \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=$GEMINI_API_KEY" \
            -H "Content-Type: application/json" \
            -d '{"contents":[{"parts":[{"text":"Test"}]}]}')
          
          if echo "$TEST" | grep -q '"error"'; then
            echo "‚ùå API Key invalid"
            exit 1
          fi
          
          echo "‚úÖ API Key valid"

      - name: Extract version from workflow name
        id: extract_ver
        run: |
          WORKFLOW_NAME="${{ github.event.workflow_run.name }}"
          VERSION=$(echo "$WORKFLOW_NAME" | grep -oE 'ver[0-9]+' || echo "ver-unknown")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Extracted version: $VERSION"

      - name: Call Gemini API for intelligent analysis
        id: ai_analysis
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          # Limit to 20KB to stay within token limits
          LOG_TEXT=$(head -c 20000 log-for-ai.txt | tr -d '\000-\037' | sed 's/"/\\"/g')
          
          PROMPT="B·∫°n l√† chuy√™n gia ph√¢n t√≠ch l·ªói FFmpeg Android ARM32.

          WORKFLOW: ${{ github.event.workflow_run.name }}
          VERSION: ${{ steps.extract_ver.outputs.version }}
          RUN: #${{ github.event.workflow_run.run_number }}
          
          CONTEXT QUAN TR·ªåNG:
          - ${{ steps.extract_ver.outputs.version }} ƒëang build LibASS (subtitle renderer library)
          - C√°c th∆∞ vi·ªán ƒë√£ build TH√ÄNH C√îNG ·ªü ver7: x264, x265, vpx, opus, lame, twolame, ogg, vorbis, theora, speex, gsm, fribidi, fdk-aac, aom, soxr, webp, freetype, openjpeg
          - Log n√†y ƒë∆∞·ª£c tr√≠ch xu·∫•t xung quanh d√≤ng \"exit code\" (l·ªói th·∫≠t s·ª± g√¢y workflow fail)
          - Ch√∫ √Ω: T√¨m d√≤ng \"Building LibASS\" ho·∫∑c \"Build LibASS\" ƒë·ªÉ x√°c ƒë·ªãnh th∆∞ vi·ªán ƒëang build
          
          NHI·ªÜM V·ª§: Ph√¢n t√≠ch log v√† tr·∫£ v·ªÅ JSON OBJECT (KH√îNG ARRAY):
          {
            \"error_id\": \"ERROR-XXX\",
            \"error_name\": \"M√¥ t·∫£ ch√≠nh x√°c v√† ng·∫Øn g·ªçn (v√≠ d·ª•: Meson unknown options harfbuzz libtool)\",
            \"root_cause\": \"Nguy√™n nh√¢n g·ªëc r·ªÖ chi ti·∫øt, gi·∫£i th√≠ch t·∫°i sao l·ªói x·∫£y ra\",
            \"affected_library\": \"libass\",
            \"error_type\": \"DEPENDENCY|LINKER|CONFIGURE|SYNTAX|UNKNOWN\",
            \"symptoms\": [\"d√≤ng l·ªói ch√≠nh x√°c t·ª´ log\", \"tri·ªáu ch·ª©ng 2 n·∫øu c√≥\"],
            \"fix_suggestion\": \"C√°ch fix c·ª• th·ªÉ v·ªõi code example ho·∫∑c command n·∫øu c√≥ th·ªÉ\",
            \"confidence\": 90
          }
          
          L∆ØU √ù QUAN TR·ªåNG:
          - Tr·∫£ v·ªÅ OBJECT {} duy nh·∫•t, KH√îNG PH·∫¢I ARRAY [{}]
          - T·∫≠p trung v√†o l·ªói CH√çNH g√¢y exit code, KH√îNG ph·∫£i warning c·ªßa th∆∞ vi·ªán ƒë√£ build th√†nh c√¥ng
          - \"affected_library\" ph·∫£i l√† th∆∞ vi·ªán ƒêANG BUILD khi l·ªói x·∫£y ra (t√¨m d√≤ng \"Building...\")
          - KH√îNG th√™m markdown formatting (```
          - Ch·ªâ tr·∫£ v·ªÅ JSON thu·∫ßn t√∫y
          
          LOG (context xung quanh exit code):
          $LOG_TEXT"
          
          ESCAPED=$(echo "$PROMPT" | jq -Rs .)
          
          echo "üì§ Calling Gemini API..."
          
          RESP=$(curl -s -w "\nHTTP_CODE:%{http_code}" -X POST \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=$GEMINI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "{
              \"contents\": [{
                \"parts\": [{
                  \"text\": $ESCAPED
                }]
              }],
              \"generationConfig\": {
                \"temperature\": 0.1,
                \"maxOutputTokens\": 1024,
                \"responseMimeType\": \"application/json\"
              }
            }")
          
          HTTP_CODE=$(echo "$RESP" | tail -n 1 | cut -d: -f2)
          BODY=$(echo "$RESP" | sed '$d')
          
          echo "HTTP Code: $HTTP_CODE"
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "‚ùå API error"
            echo "$BODY" | jq . 2>/dev/null || echo "$BODY"
            
            cat > ai-analysis.json << 'EOF'
          {
            "error_id": "ERROR-999",
            "error_name": "Gemini API unavailable",
            "root_cause": "API returned HTTP error or is overloaded",
            "affected_library": "unknown",
            "error_type": "API_ERROR",
            "symptoms": ["API HTTP error"],
            "fix_suggestion": "Retry workflow later or check API status",
            "confidence": 20
          }
          EOF
          else
            echo "‚úÖ API success"
            
            AI=$(echo "$BODY" | jq -r '.candidates.content.parts.text' 2>/dev/null || echo "")
            
            if [ -z "$AI" ] || [ "$AI" = "null" ]; then
              echo "‚ùå Empty response from Gemini"
              cat > ai-analysis.json << 'EOF'
          {
            "error_id": "ERROR-998",
            "error_name": "Empty AI response",
            "root_cause": "Gemini returned empty content",
            "affected_library": "unknown",
            "error_type": "API_ERROR",
            "symptoms": ["Empty response"],
            "fix_suggestion": "Retry workflow",
            "confidence": 15
          }
          EOF
            else
              echo "‚úÖ Got AI response"
              echo "$AI" > ai-analysis-raw.json
              
              # CRITICAL: Handle array vs object response
              if echo "$AI" | jq -e 'type == "array"' > /dev/null 2>&1; then
                echo "‚ö†Ô∏è Gemini returned ARRAY, extracting first element"
                echo "$AI" | jq '.' > ai-analysis.json
              else
                echo "‚úÖ Gemini returned OBJECT (correct format)"
                echo "$AI" > ai-analysis.json
              fi
              
              # Validate final JSON
              if ! jq empty ai-analysis.json 2>/dev/null; then
                echo "‚ö†Ô∏è Invalid JSON from AI, creating fallback"
                cat > ai-analysis.json << 'EOF'
          {
            "error_id": "ERROR-997",
            "error_name": "Invalid JSON from AI",
            "root_cause": "JSON parse error",
            "affected_library": "unknown",
            "error_type": "API_ERROR",
            "symptoms": ["Invalid JSON structure"],
            "fix_suggestion": "Review AI prompt and response",
            "confidence": 10
          }
          EOF
              fi
            fi
          fi
          
          echo "Final JSON for Knowledge Base:"
          cat ai-analysis.json
          
          # Extract fields (guaranteed to be object now)
          echo "error_id=$(jq -r '.error_id // "ERROR-000"' ai-analysis.json)" >> $GITHUB_OUTPUT
          echo "error_name=$(jq -r '.error_name // "Unknown Error"' ai-analysis.json)" >> $GITHUB_OUTPUT
          echo "affected_lib=$(jq -r '.affected_library // "unknown"' ai-analysis.json)" >> $GITHUB_OUTPUT

      - name: Initialize Knowledge Base if not exists
        run: |
          if [ ! -f .github/ERROR_KNOWLEDGE_BASE.md ]; then
            cat > .github/ERROR_KNOWLEDGE_BASE.md << 'EOF'
          # üìö FFmpeg Android ARM32 - Error Knowledge Base

          > **M·ª•c ƒë√≠ch:** T·ª± ƒë·ªông ghi l·∫°i t·∫•t c·∫£ l·ªói build ƒë·ªÉ tr√°nh l·∫∑p l·∫°i sai l·∫ßm  
          > **C·∫≠p nh·∫≠t:** T·ª± ƒë·ªông b·ªüi AI (Gemini 2.0 Flash)  
          > **T·ªïng s·ªë l·ªói:** 0

          ---

          ## üìã Quick Reference

          | ID | L·ªói | Th∆∞ vi·ªán | Version | Ng√†y |
          |----|-----|----------|---------|------|

          ---

          ## üî¥ Chi ti·∫øt l·ªói

          EOF
            
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add .github/ERROR_KNOWLEDGE_BASE.md
            git commit -m "docs: Initialize Error Knowledge Base"
          fi

      - name: Add entry to Knowledge Base
        env:
          ERROR_ID: ${{ steps.ai_analysis.outputs.error_id }}
          ERROR_NAME: ${{ steps.ai_analysis.outputs.error_name }}
          AFFECTED_LIB: ${{ steps.ai_analysis.outputs.affected_lib }}
          VERSION: ${{ steps.extract_ver.outputs.version }}
        run: |
          JSON=$(cat ai-analysis.json)
          
          ROOT=$(echo "$JSON" | jq -r '.root_cause // "N/A"')
          TYPE=$(echo "$JSON" | jq -r '.error_type // "UNKNOWN"')
          FIX=$(echo "$JSON" | jq -r '.fix_suggestion // "N/A"')
          SYMP=$(echo "$JSON" | jq -r '.symptoms // ["N/A"] | join("\n- ")')
          CONF=$(echo "$JSON" | jq -r '.confidence // 0')
          
          # Update Quick Reference table
          sed -i "/^| ID | L·ªói/a | $ERROR_ID | $ERROR_NAME | $AFFECTED_LIB | $VERSION | $(date +%Y-%m-%d) |" .github/ERROR_KNOWLEDGE_BASE.md
          
          # Update total count
          TOTAL=$(grep -c "^### üî¥ ERROR-" .github/ERROR_KNOWLEDGE_BASE.md 2>/dev/null || echo "0")
          TOTAL=$(echo "$TOTAL" | tr -d '\n\r ')
          NEW=$((TOTAL + 1))
          sed -i "s/T·ªïng s·ªë l·ªói:\*\* [0-9]*/T·ªïng s·ªë l·ªói:** $NEW/" .github/ERROR_KNOWLEDGE_BASE.md
          
          # Add detailed entry
          cat >> .github/ERROR_KNOWLEDGE_BASE.md << EOF

          ### üî¥ $ERROR_ID: $ERROR_NAME

          **üìÖ Ng√†y:** $(date +%Y-%m-%d) | **üì¶ Workflow:** ${{ github.event.workflow_run.name }} | **üîó Run:** [#${{ github.event.workflow_run.run_number }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.event.workflow_run.id }})

          **üéØ Th∆∞ vi·ªán:** \`$AFFECTED_LIB\` | **üè∑Ô∏è Version:** \`$VERSION\` | **ü§ñ ƒê·ªô tin c·∫≠y AI:** ${CONF}%

          **‚ö†Ô∏è Tri·ªáu ch·ª©ng:**
          - $SYMP

          **üîç Nguy√™n nh√¢n g·ªëc r·ªÖ:**  
          $ROOT

          **üõ†Ô∏è G·ª£i √Ω fix:**  
          $FIX

          **üìù Lo·∫°i l·ªói:** \`$TYPE\`

          ---

          EOF

      - name: Commit and push to repository
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add .github/ERROR_KNOWLEDGE_BASE.md
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "ü§ñ ${{ steps.ai_analysis.outputs.error_id }}: ${{ steps.ai_analysis.outputs.error_name }} [${{ steps.extract_ver.outputs.version }}]"
            git push
            echo "‚úÖ Successfully pushed to repository"
          fi

      - name: Generate job summary
        if: always()
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ‚úÖ Analysis Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ steps.extract_ver.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow:** ${{ github.event.workflow_run.name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Error ID:** ${{ steps.ai_analysis.outputs.error_id }}" >> $GITHUB_STEP_SUMMARY
          echo "**Affected Library:** ${{ steps.ai_analysis.outputs.affected_lib }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ü§ñ AI Analysis JSON:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`json" >> $GITHUB_STEP_SUMMARY
          cat ai-analysis.json 2>/dev/null || echo "{}"
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìÑ Knowledge Base:" >> $GITHUB_STEP_SUMMARY
          echo "[üìñ View ERROR_KNOWLEDGE_BASE.md](https://github.com/${{ github.repository }}/blob/main/.github/ERROR_KNOWLEDGE_BASE.md)" >> $GITHUB_STEP_SUMMARY

      - name: Cleanup temporary files
        if: always()
        run: |
          rm -rf current-log/ current-log.zip full-log.txt log-for-ai.txt ai-analysis.json ai-analysis-raw.json 2>/dev/null || true
          echo "‚úÖ Cleanup complete"
