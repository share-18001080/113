name: AI Knowledge Base (Full Log Upload)

on:
  workflow_run:
    workflows: ["*"]
    types: [completed]

permissions:
  actions: read
  contents: write

jobs:
  ai-analyze-error:
    runs-on: ubuntu-latest
    if: |
      github.event.workflow_run.conclusion == 'failure' &&
      contains(github.event.workflow_run.name, 'ver') &&
      !contains(github.event.workflow_run.name, 'AI Knowledge Base')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Debug workflow info
        run: |
          echo "## 🔍 Workflow Info" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.event.workflow_run.name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Run ID:** ${{ github.event.workflow_run.id }}" >> $GITHUB_STEP_SUMMARY
          echo "**Run #:** ${{ github.event.workflow_run.run_number }}" >> $GITHUB_STEP_SUMMARY

      - name: Download and extract error context
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          FAILED_RUN_ID=${{ github.event.workflow_run.id }}
          
          echo "📥 Downloading log for run $FAILED_RUN_ID"
          
          curl -L \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/${FAILED_RUN_ID}/logs" \
            -o current-log.zip
          
          if [ ! -f current-log.zip ]; then
            echo "❌ Failed to download log"
            exit 1
          fi
          
          SIZE=$(stat -c%s current-log.zip 2>/dev/null || stat -f%z current-log.zip)
          echo "✅ Downloaded: ${SIZE} bytes"
          
          unzip -q current-log.zip -d current-log/
          find current-log/ -name "*.txt" -exec cat {} \; > full-log.txt
          
          TOTAL_LINES=$(wc -l < full-log.txt)
          echo "📊 Total lines: $TOTAL_LINES"
          
          echo "🔍 Searching for exit code markers..."
          EXIT_CODE_LINES=$(grep -n "exit code [1-9]" full-log.txt | cut -d: -f1)
          
          if [ -z "$EXIT_CODE_LINES" ]; then
            echo "⚠️ No exit code found, trying error marker"
            EXIT_CODE_LINES=$(grep -n "##\[error\]" full-log.txt | head -n 1 | cut -d: -f1)
          fi
          
          if [ -n "$EXIT_CODE_LINES" ]; then
            FIRST_EXIT=$(echo "$EXIT_CODE_LINES" | head -n 1)
            echo "✅ Found exit code at line: $FIRST_EXIT"
            
            # Extract FULL 3000 lines context (NO LIMIT)
            START_LINE=$((FIRST_EXIT - 3000))
            END_LINE=$((FIRST_EXIT + 100))
            
            if [ $START_LINE -lt 1 ]; then
              START_LINE=1
            fi
            
            if [ $END_LINE -gt $TOTAL_LINES ]; then
              END_LINE=$TOTAL_LINES
            fi
            
            echo "📍 Extracting lines $START_LINE to $END_LINE"
            sed -n "${START_LINE},${END_LINE}p" full-log.txt > log-for-ai.txt
            
            EXTRACTED=$(wc -l < log-for-ai.txt)
            FILE_SIZE=$(stat -c%s log-for-ai.txt 2>/dev/null || stat -f%z log-for-ai.txt)
            echo "📤 Extracted $EXTRACTED lines ($FILE_SIZE bytes) for AI"
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### 🚨 Exit Code Found:" >> $GITHUB_STEP_SUMMARY
            echo "Line: $FIRST_EXIT" >> $GITHUB_STEP_SUMMARY
            echo "Context: $EXTRACTED lines ($FILE_SIZE bytes)" >> $GITHUB_STEP_SUMMARY
            
          else
            echo "⚠️ No exit code found, using full log"
            cp full-log.txt log-for-ai.txt
          fi

      - name: Test Gemini API Key
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          if [ -z "$GEMINI_API_KEY" ]; then
            echo "❌ GEMINI_API_KEY not set"
            exit 1
          fi
          echo "✅ API Key configured"

      - name: Extract version
        id: extract_ver
        run: |
          VERSION=$(echo "${{ github.event.workflow_run.name }}" | grep -oE 'ver[0-9]+' || echo "ver-unknown")
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Upload log to Gemini and analyze (FULL FILE)
        id: ai_analysis
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          echo "📤 Uploading FULL log file to Gemini..."
          
          FILE_SIZE=$(stat -c%s log-for-ai.txt)
          echo "File size: $FILE_SIZE bytes"
          
          # Step 1: Initialize resumable upload
          INIT_RESP=$(curl -s -X POST \
            "https://generativelanguage.googleapis.com/upload/v1beta/files?key=$GEMINI_API_KEY" \
            -H "X-Goog-Upload-Protocol: resumable" \
            -H "X-Goog-Upload-Command: start" \
            -H "X-Goog-Upload-Header-Content-Length: $FILE_SIZE" \
            -H "X-Goog-Upload-Header-Content-Type: text/plain" \
            -H "Content-Type: application/json" \
            -d "{\"file\": {\"display_name\": \"build-error-ver8-log.txt\"}}")
          
          UPLOAD_URL=$(echo "$INIT_RESP" | grep -i "x-goog-upload-url:" | cut -d' ' -f2- | tr -d '\r')
          
          if [ -z "$UPLOAD_URL" ]; then
            echo "❌ Failed to get upload URL"
            echo "Response: $INIT_RESP"
            exit 1
          fi
          
          echo "✅ Got upload URL"
          
          # Step 2: Upload file content
          UPLOAD_RESP=$(curl -s -X POST "$UPLOAD_URL" \
            -H "Content-Length: $FILE_SIZE" \
            -H "X-Goog-Upload-Offset: 0" \
            -H "X-Goog-Upload-Command: upload, finalize" \
            --data-binary @log-for-ai.txt)
          
          FILE_URI=$(echo "$UPLOAD_RESP" | jq -r '.file.uri // empty')
          FILE_STATE=$(echo "$UPLOAD_RESP" | jq -r '.file.state // empty')
          
          if [ -z "$FILE_URI" ]; then
            echo "❌ Failed to upload file"
            echo "Response: $UPLOAD_RESP"
            exit 1
          fi
          
          echo "✅ Uploaded file: $FILE_URI"
          echo "File state: $FILE_STATE"
          
          # Step 3: Wait for file processing (ACTIVE state)
          echo "⏳ Waiting for file processing..."
          MAX_WAIT=30
          WAITED=0
          
          while [ "$FILE_STATE" != "ACTIVE" ] && [ $WAITED -lt $MAX_WAIT ]; do
            sleep 2
            WAITED=$((WAITED + 2))
            
            STATUS=$(curl -s -X GET \
              "https://generativelanguage.googleapis.com/v1beta/$FILE_URI?key=$GEMINI_API_KEY")
            
            FILE_STATE=$(echo "$STATUS" | jq -r '.state // "UNKNOWN"')
            echo "State: $FILE_STATE (waited ${WAITED}s)"
            
            if [ "$FILE_STATE" = "ACTIVE" ]; then
              break
            fi
          done
          
          if [ "$FILE_STATE" != "ACTIVE" ]; then
            echo "⚠️ File not ACTIVE after ${WAITED}s, proceeding anyway"
          fi
          
          # Step 4: Generate content with file
          cat > analysis-prompt.txt << 'EOFPROMPT'
          Bạn là chuyên gia phân tích lỗi FFmpeg Android ARM32.
          
          WORKFLOW: Build FFmpeg Android ARM32 (Full Features + LibASS Added - ver8)
          VERSION: ver8
          
          CONTEXT:
          - ver8 đang build LibASS (subtitle renderer library)
          - Thư viện đã OK ở ver7: x264, x265, vpx, opus, lame, twolame, ogg, vorbis, theora, speex, gsm, fribidi, fdk-aac, aom, soxr, webp, freetype, openjpeg
          - File đính kèm là LOG ĐẦY ĐỦ xung quanh exit code
          
          NHIỆM VỤ: Phân tích TOÀN BỘ file log và trả về JSON:
          {
            "error_id": "ERROR-XXX",
            "error_name": "Mô tả chính xác",
            "root_cause": "Nguyên nhân gốc rễ chi tiết",
            "affected_library": "libass",
            "error_type": "DEPENDENCY|LINKER|CONFIGURE|SYNTAX|UNKNOWN",
            "symptoms": ["dòng lỗi chính xác"],
            "fix_suggestion": "Cách fix cụ thể với command/code",
            "confidence": 90
          }
          
          LƯU Ý:
          - Trả về OBJECT {}, KHÔNG ARRAY
          - Tìm dòng "Building LibASS" để xác định thư viện
          - Tìm dòng "ERROR:" hoặc "error:" để xác định lỗi chính
          - KHÔNG giới hạn phân tích - đọc TOÀN BỘ file
          EOFPROMPT
          
          PROMPT_TEXT=$(cat analysis-prompt.txt)
          
          echo "📤 Calling Gemini with file reference..."
          
          GEN_RESP=$(curl -s -X POST \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=$GEMINI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "{
              \"contents\": [{
                \"parts\": [
                  {\"text\": \"$PROMPT_TEXT\"},
                  {\"file_data\": {
                    \"file_uri\": \"$FILE_URI\",
                    \"mime_type\": \"text/plain\"
                  }}
                ]
              }],
              \"generationConfig\": {
                \"temperature\": 0.1,
                \"maxOutputTokens\": 2048,
                \"responseMimeType\": \"application/json\"
              }
            }")
          
          echo "Response received"
          
          # Parse AI response
          AI_TEXT=$(echo "$GEN_RESP" | jq -r '.candidates[0].content.parts[0].text // empty')
          
          if [ -z "$AI_TEXT" ]; then
            echo "❌ Empty AI response"
            echo "Full response:"
            echo "$GEN_RESP" | jq .
            
            cat > ai-analysis.json << 'EOFERR'
          {
            "error_id": "ERROR-998",
            "error_name": "Empty AI response",
            "root_cause": "Gemini returned empty or error",
            "affected_library": "unknown",
            "error_type": "API_ERROR",
            "symptoms": ["Empty response"],
            "fix_suggestion": "Check API quota or retry",
            "confidence": 20
          }
          EOFERR
          else
            echo "✅ Got AI analysis"
            echo "$AI_TEXT" > ai-analysis-raw.json
            
            # Handle array vs object
            if echo "$AI_TEXT" | jq -e 'type == "array"' > /dev/null 2>&1; then
              echo "⚠️ Converting array to object"
              echo "$AI_TEXT" | jq '.[0]' > ai-analysis.json
            else
              echo "✅ Got object"
              echo "$AI_TEXT" > ai-analysis.json
            fi
            
            # Validate
            if ! jq empty ai-analysis.json 2>/dev/null; then
              echo "⚠️ Invalid JSON, using fallback"
              cat > ai-analysis.json << 'EOFERR'
          {
            "error_id": "ERROR-997",
            "error_name": "Invalid JSON from AI",
            "root_cause": "JSON parse error",
            "affected_library": "unknown",
            "error_type": "API_ERROR",
            "symptoms": ["Invalid JSON"],
            "fix_suggestion": "Review prompt",
            "confidence": 15
          }
          EOFERR
            fi
          fi
          
          echo "Final JSON:"
          cat ai-analysis.json
          
          # Cleanup uploaded file
          echo "🧹 Deleting uploaded file from Gemini..."
          curl -s -X DELETE \
            "https://generativelanguage.googleapis.com/v1beta/$FILE_URI?key=$GEMINI_API_KEY" \
            -o /dev/null
          
          echo "error_id=$(jq -r '.error_id // "ERROR-000"' ai-analysis.json)" >> $GITHUB_OUTPUT
          echo "error_name=$(jq -r '.error_name // "Unknown"' ai-analysis.json)" >> $GITHUB_OUTPUT
          echo "affected_lib=$(jq -r '.affected_library // "unknown"' ai-analysis.json)" >> $GITHUB_OUTPUT

      - name: Initialize Knowledge Base
        run: |
          if [ ! -f .github/ERROR_KNOWLEDGE_BASE.md ]; then
            cat > .github/ERROR_KNOWLEDGE_BASE.md << 'EOFKB'
          # 📚 FFmpeg Android ARM32 - Error Knowledge Base

          > **Phân tích:** AI với FULL log context  
          > **Tổng số lỗi:** 0

          ---

          ## 📋 Quick Reference

          | ID | Lỗi | Thư viện | Version | Ngày |
          |----|-----|----------|---------|------|

          ---

          ## 🔴 Chi tiết lỗi

          EOFKB
            
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add .github/ERROR_KNOWLEDGE_BASE.md
            git commit -m "docs: Init KB"
          fi

      - name: Add entry to Knowledge Base
        env:
          ERROR_ID: ${{ steps.ai_analysis.outputs.error_id }}
          ERROR_NAME: ${{ steps.ai_analysis.outputs.error_name }}
          AFFECTED_LIB: ${{ steps.ai_analysis.outputs.affected_lib }}
          VERSION: ${{ steps.extract_ver.outputs.version }}
        run: |
          JSON=$(cat ai-analysis.json)
          
          ROOT=$(echo "$JSON" | jq -r '.root_cause // "N/A"')
          TYPE=$(echo "$JSON" | jq -r '.error_type // "UNKNOWN"')
          FIX=$(echo "$JSON" | jq -r '.fix_suggestion // "N/A"')
          SYMP=$(echo "$JSON" | jq -r '.symptoms // ["N/A"] | join("\n- ")')
          CONF=$(echo "$JSON" | jq -r '.confidence // 0')
          
          sed -i "/^| ID | Lỗi/a | $ERROR_ID | $ERROR_NAME | $AFFECTED_LIB | $VERSION | $(date +%Y-%m-%d) |" .github/ERROR_KNOWLEDGE_BASE.md
          
          TOTAL=$(grep -c "^### 🔴 ERROR-" .github/ERROR_KNOWLEDGE_BASE.md 2>/dev/null || echo "0")
          NEW=$((TOTAL + 1))
          sed -i "s/Tổng số lỗi:\*\* [0-9]*/Tổng số lỗi:** $NEW/" .github/ERROR_KNOWLEDGE_BASE.md
          
          cat >> .github/ERROR_KNOWLEDGE_BASE.md << EOFENTRY

          ### 🔴 $ERROR_ID: $ERROR_NAME

          **📅** $(date +%Y-%m-%d) | **📦** ${{ github.event.workflow_run.name }} | **🔗** [Run #${{ github.event.workflow_run.run_number }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.event.workflow_run.id }})

          **🎯 Thư viện:** \`$AFFECTED_LIB\` | **🏷️** \`$VERSION\` | **🤖** ${CONF}%

          **⚠️ Triệu chứng:**
          - $SYMP

          **🔍 Nguyên nhân:**  
          $ROOT

          **🛠️ Fix:**  
          $FIX

          **📝 Loại:** \`$TYPE\`

          ---

          EOFENTRY

      - name: Commit and push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .github/ERROR_KNOWLEDGE_BASE.md
          if ! git diff --staged --quiet; then
            git commit -m "🤖 ${{ steps.ai_analysis.outputs.error_id }}: ${{ steps.ai_analysis.outputs.error_name }} [${{ steps.extract_ver.outputs.version }}]"
            git push
            echo "✅ Pushed"
          fi

      - name: Job Summary
        if: always()
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "## ✅ Analysis Complete (FULL LOG)" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ steps.extract_ver.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Error:** ${{ steps.ai_analysis.outputs.error_id }}" >> $GITHUB_STEP_SUMMARY
          echo "**Affected:** ${{ steps.ai_analysis.outputs.affected_lib }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🤖 AI Analysis:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`json" >> $GITHUB_STEP_SUMMARY
          cat ai-analysis.json 2>/dev/null || echo "{}"
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: Cleanup
        if: always()
        run: |
          rm -rf current-log/ current-log.zip full-log.txt log-for-ai.txt ai-analysis.json ai-analysis-raw.json analysis-prompt.txt 2>/dev/null || true
